
在上一章中，我介绍了go的基础语法（变量类型、判断语句、循环语句，服务器实现等），但是go的优势纠结是什么？

## 并发vs并行

```
并发：多线程程序在一个核的CPU上运行
并行：多线程程序在多个核的CPU上运行
```
在互联网公司，高并发是面试常见的问题。高并发意味着大流量，需要运用技术手段抵抗流量的冲击，这些手段好比操作流量，能让流量更平稳地被系统所处理，带给用户更好的体验。
当今无数的 Web 服务和互联网服务，本质上大部分都是 IO 密集型服务，什么是 IO 密集型服务？意思是处理的任务大多是和网络连接或读写相关的高耗时任务，高耗时是相对 CPU 计算逻辑处理型任务来说，两者的处理时间差距不是一个数量级的。
**IO 密集型服务的瓶颈不在 CPU 处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写。**

为了解决高并发问题，以前有两种解决方案
- 如果用多线程，高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换，非常消耗系统资源，同时多线程访问共享资源存在竞争问题
- 如果用多进程，不仅存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要额外引入进程间通信机制来解决。
- 
上述两种方案看起来都不太合适，高并发是go的主要特性之一，那么go可以轻易实现高并发处理？

#### 协程

进程线程可以说是操作系统基础，运行在内核态。如果频繁的挂起和切换线程或进程，会消耗大量的系统资源，因此我们能否考虑在用户态实现一些类似线程的东西？当然可以，答案就是协程。这是go语言实现高并发的核心内容。

那究竟什么是协程呢？**协程 Coroutines 是一种比线程更加轻量级的微线程。**类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程。

**可以粗略的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。**
![[Pasted image 20230726175415.png]]

在发生调度切换时：
- 线程被内核调度，发生切换时，需要保存一个用户线程的状态到内存，恢复另一个线程状态到寄存器，然后更新调度器的数据结构，这几步操作涉及用户态到内核态转换，开销比较多。
- 协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方即可，再切换回来时，恢复先前保存的寄存器上下文和栈，这个过程直接操作用户空间栈，完全没有内核切换的开销。

#### Go协程的实现

协程可以很好的用来处理高并发任务，go语言也因此备受互联网企业青睐，那么go协程是如何实现的呢？

