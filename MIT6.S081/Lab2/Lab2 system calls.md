
[课程地址]([[Lab: System calls (mit.edu)](https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)])_

本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理

## 系统调用的原理

回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态：
1. **系统调用**：当用户程序执行**ecall**指令要求内核为其做某事时。
2. **异常**：一条指令(用户或内核)做了一些非法的事情，如除以零或使用无效的虚拟地址。
3. **中断**：当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。

所以研究系统调用，其实也就是研究中断（trap）过程是如何发生的。宏观上可分为四个步骤，本文会针对这四个步骤，结合xv6系统进行详细的讲解：
1. 中断请求
2. 保护现场
3. 中断处理
4. 中断返回

以上过程自然离不开与寄存器打交道，例如**satp寄存器用于控制分页系统**，以下是与trap相关的寄存器概述，这些寄存器可以分为两类：
**1. 发生中断时，硬件自动写入的寄存器**
    -  `sepc`：当trap发生时，RISC-V会将程序计数器保存在这里(因为`PC`会被`stvec`覆盖)。`sret`(从trap中返回)指令将`sepc`复制到`pc`中。内核可以写`sepc`来控制`sret`的返回到哪里。
    -  `scause`：RISC -V在这里放了一个数字，描述了trap的原因。
    -  `stval`：`scause` 不足以存下中断所有的必须信息。例如缺页异常，就会将 `stval` 设置成需要访问但是不在内存中的地址，以便于操作系统将这个地址所在的页面加载进来。

**2. 指导硬件处理中断的寄存器**
    - `stvec`：保存内核中断处理流程的入口地址，内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。
    - `sstatus`：具有许多状态位，控制全局中断等。`sstatus`中的**SIE**位控制设备中断是否被启用，如果内核清除**SIE**，RISC-V将推迟设备中断，直到内核设置**SIE**。**SPP**位表示trap是来自用户模式还是supervisor模式，并控制`sret`返回到什么模式。
    - `sie`：即 Supervisor Interrupt Enable，用来控制具体类型中断，例如其中的 STIE 控制时钟中断
    - `sip`：即 Supervisor Interrupt Pending，和 `sie` 相对应，记录每种中断是否被触发。仅当 `sie` 和 `sip` 的对应位都为 1 时，意味着开中断且已发生中断，这时中断最终触发。
    - `sscratch`：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。在用户态保存内核栈的地址，在内核态值为 0。为什么需要内核栈？因此中断处理流程也需要利用内存空间，很可能需要使用栈，而程序当前的用户栈是不安全的（说不定指针不断运行到其他进程的空间，破坏了隔离性）。因此，我们还需要一个预设的安全的栈空间，存放在这里。

有了上述与中断相关的寄存器，自然也就有与中断相关的指令：
**1. 进入和退出中断**
    - `ecall`：触发中断，进入更高一层的中断处理流程之中。用户态进行系统调用进入内核态中断处理流程，内核态进行 SBI 调用进入机器态中断处理流程，使用的都是这条指令。
    - `sret`：从内核态返回用户态，同时将 `sepc` 的值赋值给 `pc`。（如果需要返回到 `sepc` 后一条指令，就需要在 `sret` 之前修改 `sepc` 的值）
    - `ebreak`：触发一个断电
    - `mret`：从机器态返回内核态，同时将 `pc` 的值设置为 `mepc`。

**2. 操作CSR**
    只有一系列特殊的指令（CSR Instruction）可以读写 CSR
    - `csrrw dst, csr, src`（CSR Read Write）同时读写的原子操作，将指定 CSR 的值写入 `dst`，同时将 `src` 的值写入 CSR。
    - `csrr dst, csr`（CSR Read）：仅读取一个 CSR 寄存器。
    - `csrw csr, src`（CSR Write）  ：仅写入一个 CSR 寄存器。

微观上，RISC-V硬件对每一个trap操作（除定时器中断外），都会执行如下步骤：
1. 如果该trap是设备中断，且sstatus SIE位为0，则不执行以下任何操作
2. 通过清除 SIE 来禁用中断
3. 复制 pc 到 sepc
4. 将当前模式(用户态或特权态)保存在 sstatus 的 SPP 位
5. 在 scause 设置该次trap的原因
6. 将模式转换为特权态
7. 将 stvec 复制到 pc
8. 从新的pc开始执行


#### 中断请求

当使用到`write，read，open`等系统调用时，会使用`ecall`指令发起中断请求
- `ecall`是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用

在xv6中，`user/cat.c`文件是`cat shell`指令的源码，其中涉及到了`read`函数，它声明在`user/user.h`文件中，但是`read`函数的实现在`kernel/sysfile.c`文件中。显然`cat`并不是直接调用`sysfile.c`文件中的函数来达成目标的，毕竟一个在用户态，一个在内核态。

既然`read`在用户态的角度看不见具体的逻辑实现，那它为什么能正常运行呢？只声明不实现的函数是无法正常使用的呀？

仔细观察user文件架，我们可以发现虽然没有`read`函数的c语言实现，但其实存在汇编实现。用户在c代码中使用`read`函数时，其实是在运行`usys.S`文件（由`usys.pl`文件得来，make指令才能看见）中`read`函数。
```
c语言如何调用汇编函数？步骤：
1、先在汇编程序中声明函数属性为GLOBAL
2、在c文件开头声明该函数
3、按照C语言正常调用函数的方式调用该函数
```

当然，这个汇编函数虽然名称也叫`read`，但并不是在执行读取文件的逻辑，而是在建立用户态与内核态的桥梁。`usys.pl`脚本的实现如下：
```c
#!/usr/bin/perl -w  
  
# Generate usys.S, the stubs for syscalls.  
  
print "# generated by usys.pl - do not edit\n";  
  
print "#include \"kernel/syscall.h\"\n";  
  
sub entry {  
    my $name = shift;  
    print ".global $name\n";  
    print "${name}:\n";  
    print " li a7, SYS_${name}\n";  
    print " ecall\n";  
    print " ret\n";  
}  
     
entry("fork");  
entry("exit");  
entry("wait");  
entry("pipe");  
entry("read");  
entry("write");  
entry("close");  
entry("kill");  
entry("exec");  
entry("open");  
entry("mknod");  
entry("unlink");  
entry("fstat");  
entry("link");  
entry("mkdir");  
entry("chdir");  
entry("dup");  
entry("getpid");  
entry("sbrk");  
entry("sleep");  
entry("uptime");
```

`usys.pl`是一个Perl语言文件。即使对Perl语言并没有深入了解，但根据语法规则可以大概了解它的作用：这个脚本文件将根据输入的字符名，通过`entry()`格式化生成文本文件。

`usys.pl`的输入是系统调用的名称，输出内容则保存为`kernel/usys.S`。这样每个系统调用都在`usys.S`文件中都有一个实现，通过`global`声明后，用户在使用同名的函数时，会执行这里的`entry()`中的逻辑：
1. 将系统调用的ID存入a7寄存器
    - 虽然输入的是名称（字符串），但是`kernel/syscall.h`文件下将字符串映射为了编号
2. 执行ecall命令
    - `ecall`是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用

这样就通过`ecall`指令（中断请求）将需要的系统调用从用户态传递给了内核态。在ecall调用过程中会发生（和前文中讲到的微观操作一致，但这里只写主要内容）：
1. 关中断
2. 代码从`user mode`改到supervisor mode
3. 程序计数器`PC`的值保存进 `SEPC` 寄存器
4. CPU执行`STVEC`寄存器指向的指令（`PC`重置为 `STVEC` 寄存器的值）

问题：那么`STVEC`寄存器的值到底是多少？
答案：`STVEC`是一个特权寄存器，只能在supervisor mode下执行，每次从内核空间返回到用户空间之前，内核会设置`STVEC`寄存器指向内核希望中断代码运行的位置（由`trap.c`中的代码设置）。

Xv6在内核页表和每个用户页表中的**同一个虚拟地址**上映射了 `trampoline page` 。`STVEC` 寄存器保存的地址是 `trampoline page` 的起始位置，主要执行一些保护用户态寄存器的操作。`trampoline page` 的首地址是 `uservec` 函数。所以其实`STVEC`指向了`kernel/trampoline.S`文件中的`uservec`函数。

**综上，其实操作系统伪装了一个系统调用的实现，当使用`read`等函数时并没有真正的读写逻辑，而是利用ecall发起中断，并通过寄存器将函数的ID告知内核，方便在内核找到函数真正的实现。**

#### 保护现场

上文讲到CPU将执行`uservec`函数（`kernel/trampoline.S`）

```c
.globl uservec  
uservec:      
   #  
        # trap.c sets stvec to point here, so  
        # traps from user space start here,  
        # in supervisor mode, but with a  
        # user page table.  
        #  
        # sscratch points to where the process's p->trapframe is  
        # mapped into user space, at TRAPFRAME.  
        #  
        # swap a0 and sscratch  
        # so that a0 is TRAPFRAME  
        csrrw a0, sscratch, a0 
  
        # save the user registers in TRAPFRAME  
        sd ra, 40(a0)  
        sd sp, 48(a0)  
        sd gp, 56(a0)  
        sd tp, 64(a0)  
        sd t0, 72(a0)  
        sd t1, 80(a0)  
        sd t2, 88(a0)  
        sd s0, 96(a0)  
        sd s1, 104(a0)  
        sd a1, 120(a0)  
        sd a2, 128(a0)  
        sd a3, 136(a0)  
        sd a4, 144(a0)  
        sd a5, 152(a0)  
        sd a6, 160(a0)  
        sd a7, 168(a0)  
        sd s2, 176(a0)  
        sd s3, 184(a0)  
        sd s4, 192(a0)  
        sd s5, 200(a0)  
        sd s6, 208(a0)  
        sd s7, 216(a0)  
        sd s8, 224(a0)  
        sd s9, 232(a0)  
        sd s10, 240(a0)  
        sd s11, 248(a0)  
        sd t3, 256(a0)  
        sd t4, 264(a0)  
        sd t5, 272(a0)  
        sd t6, 280(a0)  
  
   # save the user a0 in p->trapframe->a0  
        csrr t0, sscratch  
        sd t0, 112(a0)  
  
        # restore kernel stack pointer from p->trapframe->kernel_sp  
        ld sp, 8(a0)  
  
        # make tp hold the current hartid, from p->trapframe->kernel_hartid  
        ld tp, 32(a0)  
  
        # load the address of usertrap(), p->trapframe->kernel_trap  
        ld t0, 16(a0)  
  
        # restore kernel page table from p->trapframe->kernel_satp  
        ld t1, 0(a0)  
        csrw satp, t1  //切换到内核页表
        sfence.vma zero, zero  
  
        # a0 is no longer valid, since the kernel page  
        # table does not specially map p->tf.  
  
        # jump to usertrap(), which does not return  
        jr t0
```

在进程的结构中有一个结构体变量名为`trapframe`，它的作用是：
1. 发生中断时，保存进程在用户态使用的各种寄存器的值，以便于到时候恢复进程运行状态。
2. 保存完成后，加载进程在内核态运行需要使用的寄存器的值

在上面的代码中：
1. 先使用`csrrw`指令，将a0寄存器设置为`sscratch`寄存器的值，此时a0指向进程的`trapframe`结构。按照特定的顺序，保存寄存器的值。从偏移量40开始是因为，0到40（5 * 8）之间保存了5个内核态相关的值`（kernel_satp，kernel_sp，kernel_trap，epc，kernel_hartid）`，具体可参考`proc.h`文件中`trapframe`的结构。
2. 恢复内核栈指针，将5个内核态相关的值加载进寄存器中，然后强制跳转执行`usertrap`函数（地址存储在`p->trapframe->kernel_trap`）。

#### 中断处理

在保存好上下文之后就要开始执行中断处理的逻辑了，这里使用的栈已经从用户栈变成了内核栈
`usertrap`函数的代码如下：
```c
//  
// handle an interrupt, exception, or system call from user space.  
// called from trampoline.S  
//  
void  
usertrap(void)  
{  
  int which_dev = 0;  
  
  if((r_sstatus() & SSTATUS_SPP) != 0)   //判断中断是否合法
    panic("usertrap: not from user mode");  
  
  // send interrupts and exceptions to kerneltrap(),  
  // since we're now in the kernel.  
  w_stvec((uint64)kernelvec);  

  struct proc *p = myproc();  
    
  // save user program counter.  
  p->trapframe->epc = r_sepc();  //保存sepc寄存器的值，前文提到了ecall指令执行后会将当前的PC保存到sepc中，因此 p->trapframe->epc其实指向ecall的最后一条指令
    
  if(r_scause() == 8){   //scause记录了发生中断的原因，8是系统调用的代号
    // system call  
  
    if(p->killed)  
      exit(-1);  
  
    // sepc points to the ecall instruction,  
    // but we want to return to the next instruction.    
    p->trapframe->epc += 4;   //此时epc指向ecall，我们恢复上下文后执行下一条指令，因此+4
  
    // an interrupt will change sstatus &c registers,  
    // so don't enable until done with those registers.    
    intr_on();   //开中断，允许内核在执行系统调用时嵌套中断
  
    syscall(); 
  } else if((which_dev = devintr()) != 0){  
    // ok  
  } else {  
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);  
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());  
    p->killed = 1;  
  }  
  
  if(p->killed)  
    exit(-1);  
  
  // give up the CPU if this is a timer interrupt.  
  if(which_dev == 2)  
    yield();  
  
  usertrapret();  
}
```

`usertrap`负责中断处理，主要通过调用三个函数完成`syscall,yield,usertrapret`

`yield`是在发生时钟中断时的处理逻辑，进程修改自己的状态并自愿放弃CPU使用权
```c
// Give up the CPU for one scheduling round.  
void  
yield(void)  
{  
  struct proc *p = myproc();  
  acquire(&p->lock);  
  p->state = RUNNABLE;  
  sched();  
  release(&p->lock);  
}
```

`syscall()`是在发生系统调用时的处理逻辑：
```c
void  
syscall(void)  
{  
  int num;  
  struct proc *p = myproc();  
  
  num = p->trapframe->a7;  
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {  
    p->trapframe->a0 = syscalls[num]();  //执行系统调用
  } else {  
    printf("%d %s: unknown sys call %d\n",  
            p->pid, p->name, num);  
    p->trapframe->a0 = -1;  
  }  
}
```

前文讲到在使用函数`read`时，并没有真正的实现代码，而是一步一步走到了这里，现在终于可以开始执行具体的`read`逻辑了。在`syscall`函数中，a7寄存器中保存了`read`的编号，系统调用表提供了一个从编号到对应函数指针的实现，通过函数指针就能找到对应需要执行的函数。

```c
//syscalls是一个函数指针数组
static uint64 (*syscalls[])(void) = {  
[SYS_fork]    sys_fork,   //sys_fork是一个宏定义，其实是数字1
[SYS_exit]    sys_exit,   //同理
[SYS_wait]    sys_wait,  
[SYS_pipe]    sys_pipe,  
[SYS_read]    sys_read,  
[SYS_kill]    sys_kill,  
[SYS_exec]    sys_exec,  
[SYS_fstat]   sys_fstat,  
[SYS_chdir]   sys_chdir,  
[SYS_dup]     sys_dup,  
[SYS_getpid]  sys_getpid,  
[SYS_sbrk]    sys_sbrk,  
[SYS_sleep]   sys_sleep,  
[SYS_uptime]  sys_uptime,  
[SYS_open]    sys_open,  
[SYS_write]   sys_write,  
[SYS_mknod]   sys_mknod,  
[SYS_unlink]  sys_unlink,  
[SYS_link]    sys_link,  
[SYS_mkdir]   sys_mkdir,  
[SYS_close]   sys_close,  
};
```

`sys_read`代码如下，此时才执行真正的`read`逻辑
```c
uint64  
sys_read(void)  
{  
  struct file *f;  
  int n;  
  uint64 p;  
  
  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)  
    return -1;  
  return fileread(f, p, n);  
}
```

`p->trapframe->a0 = syscalls[num]();`完成了系统调用过程并将返回值保存在a0寄存器，系统调用逻辑执行完毕，因此需要开始中断返回。

#### 中断返回

`usertrapret`函数被`usertrap`调用，用来从内核态返回用户态
```c
//  
// return to user space  
//  
void  
usertrapret(void)  
{  
  struct proc *p = myproc();   
  
  // we're about to switch the destination of traps from  
  // kerneltrap() to usertrap(), so turn off interrupts until  
  // we're back in user space, where usertrap() is correct.  
  intr_off();  //关中断，不能在执行中断恢复过程时嵌套中断
  
  // send syscalls, interrupts, and exceptions to trampoline.S  
  // 因为在执行ecall指令后，CPU几哦执行STVEC寄存器指向的指令（PC重置为 STVEC寄存器的值）
  // 所以设置STVEC寄存器的值为我们想要中断发生时执行的代码的地址（前文提到的uservec函数）
  w_stvec(TRAMPOLINE + (uservec - trampoline));  
  
  // set up trapframe values that uservec will need when  
  // the process next re-enters the kernel.  
  // 和发生中断时保存上下文类似，内核使用完毕，即将进入用户态，要将目前的值保存起来，
  p->trapframe->kernel_satp = r_satp();         // kernel page table  
  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack  
  p->trapframe->kernel_trap = (uint64)usertrap;  
  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()  
  
  // set up the registers that trampoline.S's sret will use  // to get to user space.     // set S Previous Privilege mode to User.  
  // 设置CPU特权等级，从supervisor mode 到user mode（也就是将操作系统从内核态修改为用户态）
  unsigned long x = r_sstatus();  
  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode  
  x |= SSTATUS_SPIE; // enable interrupts in user mode  
  w_sstatus(x);  
  
  // set S Exception Program Counter to the saved user pc.  
  w_sepc(p->trapframe->epc);   //修改sepc寄存器的值，在sret指令后，sepc的值会写入pc，此时sepc指向ecall的下一条指令
  
  // tell trampoline.S the user page table to switch to.  
  uint64 satp = MAKE_SATP(p->pagetable);  
  
  // jump to trampoline.S at the top of memory, which   
  // switches to the user page table, restores user registers,  
  // and switches to user mode with sret.  
  uint64 fn = TRAMPOLINE + (userret - trampoline);  
  
  //调用userret函数（trampoline.S），userret(TRAPFRAME, pagetable)
  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp); 
}

```

`userret`函数如下：
```c
.globl userret  
userret:  
        # userret(TRAPFRAME, pagetable)  
        # switch from kernel to user.  
        # usertrapret() calls here.  
        # a0: TRAPFRAME, in user page table.   函数传参时使用a0，a1寄存器
        # a1: user page table, for satp.  
  
        # switch to the user page table.  
        csrw satp, a1  
        sfence.vma zero, zero  
  
        # put the saved user a0 in sscratch, so we  
        # can swap it with our a0 (TRAPFRAME) in the last step.  
        ld t0, 112(a0)  
        csrw sscratch, t0  
  
        # restore all but a0 from TRAPFRAME  
        ld ra, 40(a0)  
        ld sp, 48(a0)  
        ld gp, 56(a0)  
        ld tp, 64(a0)  
        ld t0, 72(a0)  
        ld t1, 80(a0)  
        ld t2, 88(a0)  
        ld s0, 96(a0)  
        ld s1, 104(a0)  
        ld a1, 120(a0)  
        ld a2, 128(a0)  
        ld a3, 136(a0)  
        ld a4, 144(a0)  
        ld a5, 152(a0)  
        ld a6, 160(a0)  
        ld a7, 168(a0)  
        ld s2, 176(a0)  
        ld s3, 184(a0)  
        ld s4, 192(a0)  
        ld s5, 200(a0)  
        ld s6, 208(a0)  
        ld s7, 216(a0)  
        ld s8, 224(a0)  
        ld s9, 232(a0)  
        ld s10, 240(a0)  
        ld s11, 248(a0)  
        ld t3, 256(a0)  
        ld t4, 264(a0)  
        ld t5, 272(a0)  
        ld t6, 280(a0)  
  
   # restore user a0, and save TRAPFRAME in sscratch  
        csrrw a0, sscratch, a0  
          
        # return to user mode and user pc.  
        # usertrapret() set up sstatus and sepc.  
        sret
```

`userret`代码的主要功能和`uservec`正好相反，后者是将用户运行时的寄存器信息保存起来，切换到内核页表；前者是将这些保存起来的寄存器值恢复回去，切换到用户页表

随着`sret`指令的调用，整个中断过程完成，sepc寄存器中的值填回pc，用户程序恢复正常执行

## System call tracing