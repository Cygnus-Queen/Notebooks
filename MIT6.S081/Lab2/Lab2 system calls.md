
[课程地址]([[Lab: System calls (mit.edu)](https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)])_

本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理

## 系统调用的原理

回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态：
1. **系统调用**：当用户程序执行**ecall**指令要求内核为其做某事时。
2. **异常**：一条指令(用户或内核)做了一些非法的事情，如除以零或使用无效的虚拟地址。
3. **中断**：当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。

所以研究系统调用，其实也就是研究中断（trap）过程是如何发生的。宏观上可分为四个步骤：
1. 中断请求
2. 保护现场
3. 中断处理
4. 中断返回

以上过程自然离不开与寄存器打交道，以下是与trap相关的寄存器概述，不少寄存器已经在之前的文本阅读部分介绍过了：
- `stvec`：内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。
- `sepc`：当trap发生时，RISC-V会将程序计数器保存在这里(因为`PC`会被`stvec`覆盖)。`sret`(从trap中返回)指令将`sepc`复制到`pc`中。内核可以写`sepc`来控制`sret`的返回到哪里。
- `scause`：RISC -V在这里放了一个数字，描述了trap的原因。
- `sscratch`：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。
- `sstatus`：`sstatus`中的**SIE**位控制设备中断是否被启用，如果内核清除**SIE**，RISC-V将推迟设备中断，直到内核设置**SIE**。**SPP**位表示trap是来自用户模式还是supervisor模式，并控制`sret`返回到什么模式。

因此微观上，RISC-V硬件对每一个trap操作（除定时器中断外），都会执行的步骤如下：
1. 如果该trap是设备中断，且sstatus SIE位为0，则不执行以下任何操作
2. 通过清除 SIE 来禁用中断
3. 复制 pc 到 sepc
4. 将当前模式(用户态或特权态)保存在 sstatus 的 SPP 位
5. 在 scause 设置该次trap的原因
6. 将模式转换为特权态
7. 将 stvec 复制到 pc
8. 从新的pc开始执行


#### 中断请求

当使用到`write，read，open`等系统调用时，会使用`ecall`指令发起中断请求
- `ecall`是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用

具体来说，在xv6中，`user/cat.c`文件是`cat shell`指令的源码，涉及到的`read`函数，声明在`user/user.h`文件中，但是read函数的实现在`kernel/sysfile.c`文件中。显然`cat`并不是直接调用`sysfile.c`文件中的函数来达成目标的，毕竟一个在用户态，一个在内核态。

所以其实此时最重要的一点就是如何建立用户态下`read`声明和内核态下`read`实现的桥梁。既然`read`在用户态的角度看不见具体的逻辑实现，但是只声明不实现的函数是无法正常使用的呀？

仔细观察user文件架，我们可以发现虽然没有`read`函数的c语言实现，但其实存在汇编实现。用户在c代码中使用`read`函数时，具体是在运行`usys.S`文件（由`usys.pl`文件得来，make指令才能看见）中`read`函数。
```
c语言如何调用汇编函数？步骤：
1、先在汇编程序中声明函数属性为GLOBAL
2、在c文件开头声明该函数
3、按照C语言正常调用函数的方式调用该函数
```

当然，这个汇编函数虽然名称也叫`read`，但并不是在执行读取文件的逻辑，而是在建立用户与内核的桥梁。`usys.pl`脚本的实现如下：
```c
#!/usr/bin/perl -w  
  
# Generate usys.S, the stubs for syscalls.  
  
print "# generated by usys.pl - do not edit\n";  
  
print "#include \"kernel/syscall.h\"\n";  
  
sub entry {  
    my $name = shift;  
    print ".global $name\n";  
    print "${name}:\n";  
    print " li a7, SYS_${name}\n";  
    print " ecall\n";  
    print " ret\n";  
}  
     
entry("fork");  
entry("exit");  
entry("wait");  
entry("pipe");  
entry("read");  
entry("write");  
entry("close");  
entry("kill");  
entry("exec");  
entry("open");  
entry("mknod");  
entry("unlink");  
entry("fstat");  
entry("link");  
entry("mkdir");  
entry("chdir");  
entry("dup");  
entry("getpid");  
entry("sbrk");  
entry("sleep");  
entry("uptime");
```

`usys.pl`是一个Perl语言文件。即使对Perl语言并没有深入了解，但根据语法规则可以大概了解它的作用：这个脚本文件将根据输入的字符名，通过`entry()`格式化生成文本文件。

实际上，`usys.pl`的输入是系统调用的名称，输出内容则保存为`kernel/usys.S`。这样每个系统调用都在`usys.S`文件中都有一个实现，通过`global`声明后，用户在使用同名的函数时，会执行这里的`entry()`中的逻辑：
1. 将系统调用的ID存入a7寄存器
    - 虽然输入的是名称（字符串），但是`kernel/syscall.h`文件下将字符串映射为了编号
2. 执行ecall命令
    - `ecall`是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用

这样就通过`ecall`指令（中断请求）将需要的系统调用从用户态传递给了内核态。在ecall调用过程中会发生（和前文中讲到的微观操作一致，但这里只写主要内容）：
1. 关中断
2. 代码从user mode改到supervisor mode
3. 程序计数器`PC`的值保存进 `SEPC` 寄存器
4. CPU执行`STVEC`寄存器指向的指令（`PC`重置为 `STVEC` 寄存器的值）

问题：那么STVEC寄存器的值到底是多少？
答案：STVEC是一个特权寄存器，只能在supervisor mode下执行，每次从内核空间返回到用户空间之前，内核会设置STVEC寄存器指向内核希望trap代码运行的位置（具体由trap.c设置了STVEC寄存器的指向）。

Xv6在内核页表和每个用户页表中的**同一个虚拟地址**上映射了 `trampoline page` 。`STVEC` 寄存器保存的地址是 `trampoline page` 的起始位置，主要执行一些保护用户态寄存器的操作。`trampoline page` 的首地址是 `uservec` 函数。所以其实STVEC指向了`kernel/trampoline.S`文件中的`uservec`函数。

综上，其实操作系统伪装了一个系统调用的实现，当使用`read`等函数时并没有真正的读写逻辑，而是发起中断，并通过寄存器将函数的ID告知内核，方便内核找到函数真正的实现。

#### 保护现场

## System call tracing




