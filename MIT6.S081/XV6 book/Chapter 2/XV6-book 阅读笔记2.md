	
# Chapter2 操作系统组织结构

Chapter 1中主要提到了操作系统提供的常见接口（系统调用），并且利用这些接口实现了一些可以在shell窗口运行的程序，但是并没有进入到内核中去。

一个操作系统最核心的功能就是给用户提供使用硬件的环境，可以井井有条的运行多个程序。这个过程涉及到了几个问题：
1. 操作系统如何为进程分配资源？（资源分配）
2. 操作系统如何确保所有进程都能执行？即使进程数量大于CPU数量（进程调度），
3. 一个进程发生故障怎样才能不影响其他进程？（隔离）
4. 进程之间如何拥有安全的交互渠道?（管道）
总的来说，上面的问题可以展现出人们对操作系统的三个核心需求：多路复用，隔离和交互

Chapter 2的主要目标就是：
1. 理解如何组织操作系统（单片内核）以实现这三个核心需求
2. 弄清楚xv6系统启动时运行的第一个进程（xv6系统的隔离单元）

注意：Xv6运行在多核RISC-V微处理器上，它的许多底层功能（例如进程实现）是针对于RISC-V的。RISC-V是64位CPU，而xv6是用“LP64”C语言编写的，这意味着C编程语言中的long数据类型和指针大小是64位，而int是32位。本书假设读者已经在某些架构上做了一些机器级编程，并将介绍risc - v特定的思想

## 操作系统抽象硬件资源的意义

为什么要有操作系统？能不能让应用程序直接和硬件发生交互？
答案是肯定的，在这种情况下，每个应用程序都有自己定制的库，可以根据硬件的特性，以最适合的方式组织应用程序的代码设计，例如嵌入式设备的操作系统

但是这样做的缺点是：如果有多个应用程序同时执行（通用PC需要同时执行很多程序），每个程序必须定期的放弃自己目前占用的CPU，使得其他程序可以运行。这个过程要求程序相互信任且不会发生错误，在普遍的计算机设备上显然是不现实的

因此在大多数情况下，将应用程序隔离，禁止直接访问敏感的硬件资源，并将资源抽象成一种服务，是更好的方案

举个例子，假如有甲乙丙丁四个人去办公室盖公章，操作系统就像一个公章管理者，提供一种叫做"盖公章"的服务，甲乙丙丁四人只需要请求这个服务，操作系统就会将公章交给他使用并进行监督，一旦使用时间到了就交给下一个人。如果没有操作系统，那么每个人都可以来争抢公章并使用，一旦甲抢到了公章并且长时间使用不归还，那么其他人就一直无法完成盖公章的任务

再从计算机的角度考虑，Unix应用程序仅通过文件系统的open、write、read和close四个系统调用与存储交互，具体的磁盘管理由操作系统来完成

再比如，Unix在进程之间切换CPU，即使A程序陷入死循环，不用担心其他程序无法运行。看起来A一直死循环占用CPU，但其实每过一定时间，A会被迫暂停运行，由其他程序占用CPU

总的来说，使用操作系统抽象硬件资源的好处和API编程时"封装"的好处类似（方便好用，隐藏内部复杂的实现细节，可移植性，可维护性等等）


## 用户模式、管理员模式和系统调用

系统调用接口就是硬件服务的抽象，这既为程序员提供了便利，又提供了强隔离的可能性。我们不希望一个程序崩溃或发生问题时影响到其他的程序，因此操作系统应该能够清理失败的应用程序并继续运行其他应用程序

为了达成这一点，操作系统必须使得应用程序不能访问其他进程的内存以及操作系统的数据结构和指令。**CPU的特权等级机制为这一要求的实现提供了硬件级别的支持**（通过设置一个模式位来实现）

例如，RISC-V有三种执行CPU指令的模式：User级中运行用户程序；Supervisor级中运行操作系统内核（和设备驱动）；Machine级中运行BootLoader和其它固件。 正常情况下，处理器一直在某个特权等级下运行，除非进入trap（诸如软硬件中断、异常等）才有可能发生特权等级的转换

对于现代操作系统（如Linux、Windows等）而已，用户程序都运行在用户态，当它们需要切换到内核态以获得更高权限时，需要向操作系统申请；而操作系统内核和设备驱动程序则默认就运行在内核态。每个用户线程也拥有两个栈，一个是用户态栈，一个是内核态栈，分别当处于用户态和内核态时使用。操作系统的用户态和内核态对应到处理器的硬件层面上，即为不同的特权等级。在RISC-V中，用户态一般对应User Mode，而内核态一般对应Supervisor Mode。

一般来说用户程序一直运行在用户态中，只有当发生中断才会转到内核态中
中断可以分为三类：
1. 系统调用（又称陷入），在程序中使用系统调用引起；
2. 异常，当应用程序运行时出现异常时（比如最常见的缺页异常）也会切换到内核态进行处理；
3. 外部中断，由CPU外部引起的中断（或者说与CPU执行指令无关的事件），如I/O中断、时钟中断


## 内核的组织方式

操作系统的哪些部分应该放在Supervisor模式运行？一种可能性是整个操作系统驻留在内核中，因此所有系统调用的实现都以Supervisor模式运行，这种组织方式被称为**单片内核**。整个操作系统以完全硬件特权运行。

这种组织使得操作系统的不同部分更容易协作，例如一个操作系统可能有一个缓冲缓存，它可以被文件系统和虚拟内存系统共享；缺点是操作系统不同部分之间的接口通常很复杂，而且内核中出现错误时会导致所有应用程序崩溃（例如windows蓝屏），计算机必须重新启动。

为了减少在内核中出错的风险，操作系统设计者可以尽量减少在管理模式下运行的操作系统代码的数量，并在用户模式下执行大部分操作系统。这种内核组织称为**微内核**，如下图所示。

文件系统作为用户级进程运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了一个进程间通信机制，将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应，内核中只保留最基本的功能（进程管理、内存管理和通信）
![[Pasted image 20230718182913.png]]


```
微内核和单片内核（宏内核）的区别：
微内核：将非基本的操作系统功能从内核移到用户态，内核中只保留最基本的功能（进程管理、内存管理和通信）
缺点：效率低，需要频繁地在用户态和内核态之间切换
优点：
1. 便于扩展操作系统，新服务可以在用户空间增加，几乎不需要修改内核。
2. 精简内核，代码量减少，更容易实现，更好debug。
3. 微内核相比于宏内核更加稳定，因为大部分功能外移，内核中可能出现的错误也相应地减少。

宏内核：将操作系统的所有功能最为一个紧密的整体都放在内核中。
缺点：不易扩展，内核出错概率更大，debug难
优点：执行效率高

微内核的操作系统有：Window,Minix,Mac等等。
宏内核的操作系统有：Unix，Linux等等。
```

XV6的内核源文件（位于kernel文件目录下）如下图所示，按照模块化的概念，源代码被粗略的分成多个文件，defs.h文件下定义了模块间的接口。
![[Pasted image 20230718183155.png]]

虽然实现比较简单，代码量可能比一般的微内核还少，但XV6在内核中实现了整个操作系统，内核接口就是操作系统接口，因此XV6属于宏内核

## 进程
