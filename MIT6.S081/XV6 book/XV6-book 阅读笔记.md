	
# Chapter1 操作系统接口

操作系统是硬件的抽象表示，需要通过接口对用户程序提供服务。我们希望尽可能设计一个简单的接口，但也会试图为上层应用程序提供更复杂的功能。unix的接口设计十分成功，而xV6是一个模仿unix内部设计的操作系统，理解xv6是理解现代操作系统的良好开端。

内核（kernel）是一种特殊的程序，为正在运行的其他程序提供服务，每个正在运行的程序，称为进程，都有包含指令、数据和堆栈的内存。这些指令实现了程序的计算。数据是计算所依赖的变量。堆栈组织程序的过程调用。

一台给定的计算机通常有许多进程，但只有一个内核。

当进程需要调用内核服务时，它调用系统调用，这是操作系统接口中的调用之一。系统调用进入内核;内核执行服务并返回。因此，进程在用户空间和内核空间中交替执行。
![[Pasted image 20230711210052.png]]

内核使用CPU提供的硬件保护机制来保证所有的进程对运行在各自的一亩三分地中，互不干扰。只有内核有权限执行这样的操作，用户程序在需要特权时会发起系统调用，执行内核中预先安排的函数。一句话来说，用户程序无法执行系统调用，当需要系统调用时，由操作系统来执行，而用户程序看到的那些系统调用代码其实是内核提供的接口。

下图列出了xv6操作系统的所有系统调用，本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段对它们进行了说明，并讨论了shell (Unix的命令行用户界面)如何使用它们。
注意：进入unix系统看到的**shell窗口是一个用户程序**而不是内核的一部分，xv6的shell代码可以在user/sh.c找到。
![[Pasted image 20230711215725.png]]

## 进程与内存

xv6进程由用户空间内存(指令、数据和堆栈)和内核私有的每个进程状态组成。
```
进程 = 占用的内存空间 + 进程状态
```

每个进程可以使用fork()系统调用创建一个新的子进程。其内存内容与父进程完全相同，父进程执行的fork会返回子进程的pid（进程的唯一标识符），子进程的fork返回0。以下面的代码为例：
```c
int pid = fork();    //创建子进程
if(pid > 0){         //如果是父进程则执行下面的语句
	printf("parent: child=%d\n", pid);
	pid = wait((int *) 0);  //wait系统调用返回当前进程退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址,如果调用者的子进程都没有退出，则等待其中一个退出,如果调用者没有子进程，wait立即返回-1, 如果父进程不关心子进程的退出状态，它可以传递一个0地址来等待
	printf("child %d is done\n", pid);
} else if(pid == 0){  //如果是子进程则执行下面的语句	
	printf("child: exiting\n");
	exit(0); //exit系统调用导致调用进程停止执行，并释放资源
} else {
	printf("fork error\n");
}

这个代码的输出结果，前两行可能交换顺序:
parent: child=1234
child: exiting
parent: child 1234 is done
```

exec系统调用从存储在文件系统中加载新的内存映像替换调用进程的内存(可以理解为把一个程序替换为另一个程序)，一般搭配fork使用

shell就是一个特殊的程序，当你在shell界面输入命令时，shell会fork一个子进程，然后使用exec将子进程的内存空间替换为你输入的命令的内存空间（也就是把子进程变成你想要执行的进程），如果内存空间不够，可以使用sbrk这一系统调用扩宽。

如下方代码所示，主循环使用getcmd从用户那里读取一行输入。然后调用fork，创建shell进程的副本。父进程调用wait，而子进程运行该命令。
```c
	// Read and run input commands.  
while(getcmd(buf, sizeof(buf)) >= 0){  
	if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){  
	// Chdir must be called by the parent, not the child.  
	buf[strlen(buf)-1] = 0; // chop \n  
	if(chdir(buf+3) < 0)  
		fprintf(2, "cannot cd %s\n", buf+3);  
		continue;  
	}  
	if(fork1() == 0)  
		runcmd(parsecmd(buf));   //子进程执行指令
	wait(0);  //父进程等待
	}    
	exit(0);  


fork1(void)  {  
	int pid;  
	pid = fork();  
	if(pid == -1)  
		panic("fork");  
	return pid;  
}
```


## I/O和文件描述符

文件描述符是一个小整数，表示进程可以读取或写入的内核管理对象