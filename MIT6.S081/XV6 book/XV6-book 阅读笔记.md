	
# Chapter1 操作系统接口

操作系统是硬件的抽象表示，需要通过接口对用户程序提供服务。我们希望尽可能设计一个简单的接口，但也会试图为上层应用程序提供更复杂的功能。unix的接口设计十分成功，而xV6是一个模仿unix内部设计的操作系统，理解xv6是理解现代操作系统的良好开端。

内核（kernel）是一种特殊的程序，为正在运行的其他程序提供服务，每个正在运行的程序，称为进程，都有包含指令、数据和堆栈的内存。这些指令实现了程序的计算。数据是计算所依赖的变量。堆栈组织程序的过程调用。

一台给定的计算机通常有许多进程，但只有一个内核。

当进程需要调用内核服务时，它调用系统调用，这是操作系统接口中的调用之一。系统调用进入内核;内核执行服务并返回。因此，进程在用户空间和内核空间中交替执行。
![[Pasted image 20230711210052.png]]

内核使用CPU提供的硬件保护机制来保证所有的进程对运行在各自的一亩三分地中，互不干扰。只有内核有权限执行这样的操作，用户程序在需要特权时会发起系统调用，执行内核中预先安排的函数。一句话来说，用户程序无法执行系统调用，当需要系统调用时，由操作系统来执行，而用户程序看到的那些系统调用代码其实是内核提供的接口。

下图列出了xv6操作系统的所有系统调用，本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段对它们进行了说明，并讨论了shell (Unix的命令行用户界面)如何使用它们。
注意：进入unix系统看到的**shell窗口是一个用户程序**而不是内核的一部分，xv6的shell代码可以在user/sh.c找到。
![[Pasted image 20230711215725.png]]

## 进程与内存

xv6进程由用户空间内存(指令、数据和堆栈)和内核私有的每个进程状态组成。
```
进程 = 占用的内存空间 + 进程状态
```

每个进程可以使用fork()系统调用创建一个新的子进程。其内存内容与父进程完全相同，父进程执行的fork会返回子进程的pid（进程的唯一标识符），子进程的fork返回0。以下面的代码为例：
```c
int pid = fork();    //创建子进程
if(pid > 0){         //如果是父进程则执行下面的语句
	printf("parent: child=%d\n", pid);
	pid = wait((int *) 0);  //wait系统调用返回当前进程退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址,如果调用者的子进程都没有退出，则等待其中一个退出,如果调用者没有子进程，wait立即返回-1, 如果父进程不关心子进程的退出状态，它可以传递一个0地址来等待
	printf("child %d is done\n", pid);
} else if(pid == 0){  //如果是子进程则执行下面的语句	
	printf("child: exiting\n");
	exit(0); //exit系统调用导致调用进程停止执行，并释放资源
} else {
	printf("fork error\n");
}

这个代码的输出结果，前两行可能交换顺序:
parent: child=1234
child: exiting
parent: child 1234 is done
```

exec系统调用从存储在文件系统中加载新的内存映像替换调用进程的内存(可以理解为把一个程序替换为另一个程序)，一般搭配fork使用

shell就是一个特殊的程序，当你在shell界面输入命令时，shell会fork一个子进程，然后使用exec将子进程的内存空间替换为你输入的命令的内存空间（也就是把子进程变成你想要执行的进程），如果内存空间不够，可以使用sbrk这一系统调用扩宽。

如下方代码所示，主循环使用getcmd从用户那里读取一行输入。然后调用fork，创建shell进程的副本。父进程调用wait，而子进程运行该命令。
```c
	// Read and run input commands.  
while(getcmd(buf, sizeof(buf)) >= 0){  
	if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){  
	// Chdir must be called by the parent, not the child.  
	buf[strlen(buf)-1] = 0; // chop \n  
	if(chdir(buf+3) < 0)  
		fprintf(2, "cannot cd %s\n", buf+3);  
		continue;  
	}  
	if(fork1() == 0)  
		runcmd(parsecmd(buf));   //子进程执行指令
	wait(0);  //父进程等待
	}    
	exit(0);  


fork1(void)  {  
	int pid;  
	pid = fork();  
	if(pid == -1)  
		panic("fork");  
	return pid;  
}
```


## I/O和文件描述符

文件描述符（File Descriptor，简称FD）是一个小整数，linux使用它来作为文件的唯一标识（文件是一个抽象概念，表示文件描述符引用的对象，不仅仅是文件夹里的文件，也可以是管道和设备），内核为每个进程维护了一个文件描述符表，这个表以为索引，再进一步指向文件的详细信息。
![[Pasted image 20230713134913.png]]

在Unix系统中，每个进程都有STDIN、STDOUT和STDERR这3种标准I/O（分别对应文件描述符0、1、2），它们是程序最通用的输入输出方式。几乎所有语言都有相应的标准I/O函数，比如，C语言可以通过scanf从终端输入字符，通过printf向终端输出字符
在这一部分内容中，主要涉及到两个系统调用，open，read和write可以[看这里]([Linux系统中I/O操作的数据读写流程介绍 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/435406445))


#### I/O重定向详解
unix通过将fork和exec分离，实现了IO重定向（让已创建的FD指向其他文件）。
具体来说，fork复制父进程的文件描述符表及其内存，这样子进程打开的文件与父进程完全相同。系统调用exec替换调用进程的内存，但保留文件表，就使得shell命令输入的IO操作可以灵活的运用。只看概念很晦涩，不妨碍看看下面案例：

dup和dup2是IO重定向的涉及的核心系统调用
```c
int dup(int oldfd); 
/**
内核在进程中创建一个新的文件描述符(目前可用文件描述符的最小值）newfd，并且使newfd指向oldfd所指向的文件表项
**/

//eg：
int main()
{
	const char *str = "hello world!\n";
	int newfd = -1;
	newfd = dup(1);    //将newfd重定向到标准输出，0、1、2是默认存在的FD，3是目前可用的最小描述符，因此newfd=3
	std::cout<<"newfd = "<<newfd<<std::endl; //输出newfd=3
	write(newfd,str,strlen(str));    //向newfd中写入字符串，由于newfd重定向到1，因此newfd和标准输出有相同的指向，会在屏幕上输出hello world!
    close(newfd); 
    //close系统调用释放一个文件描述符，使其可以被将来的open、pipe或dup系统调用重用。新分配的文       件描述符总是当前进程中编号最低的未使用描述符
	return 0;
} 
```

```c
int dup2(int oldfd, int newfd); 
/**
让传入的参数newfd与参数oldfd指向同一文件表项，如果newfd已经被open过，那么就会先将newfd关闭，然后让newfd指向oldfd所指向的文件表项，如果newfd本身就等于oldfd，那么就直接返回newfd。因此，传入的newfd既可以是open过的，也可以是一个任意非负整数，

总之，dup2函数的作用就是让newfd重定向到oldfd所指的文件表项上
如果出错就返回-1，否则返回的就是newfd
**/

//eg:
int main()
{
	const char *str = "hello world!\n";
 
	dup2(1,5);    //将“5”重定向到标准输出
	write(5,str,strlen(str));   //向文件描述符5写入数据,此时相当于输出到文件描述符1对应的文件表项上，也就是输出到屏幕
	close(5);
	return 0;
}
```

下面可以讲几个具体的样例：
**1.  重定向标准输入**
标准输入（文件描述符0）所对应的设备是键盘，当read指定FD=1时，实际上是read键盘输入的数据，那如果不想让键盘作为标准输入呢？比如说让程序从某个文件中读取输入数据，这就需要重定向标准输入
```c
int main()
{
	string rdstr;
	int fd = -1;
	//打开想要读取数据的文件，open返回新的FD，这个fd指向test.txt这一文件表项
	if((fd = open("test.txt",O_RDWR)) == -1) 	
	{
		cout<<"open failed !"<<endl;
		return -1;
	}
	//重定向标准输入到外部文件test.txt中（即0重定向到fd，指向fd对应的文件表项）
	dup2(fd,0); 
	
	while(getline(cin,rdstr))     //用getline从标准输入中获取数据，也就是从此时的fd读取
	{
		cout<<rdstr<<endl;    //通过标准输出将读入的数据打印出来
	}
 
    close(fd);
	return 0;
}

```

**2.  重定向标准输出**
标准输出（文件描述符1）的设备是显示器，通过标准输出进行write时，数据会直接输出到显示器上。那么如果想让cout、printf直接将数据输出到文件，而不是显示屏上呢？那么就需要重定向标准输出。
```c
int main()
{
	int fd = -1;
	//创建test.txt并清空文本（O_TRUNC是清空之前内容的标志），并生成文件描述符fd
	if((fd = open("test.txt",O_RDWR|O_CREAT|O_TRUNC)) == -1)  
	{
		cout<<"open failed !"<<endl;
		return -1;
	}
	dup2(fd,1);   //重定向标准输出到外部文件test.txt
	//向标准输出输出数据，此时的标准输出指向了fd指向的文本表项，也就是test.txt
	cout<<"重定向标准输出测试！"<<endl;   
    close(fd);
	return 0;
}
```
扩展：

**3.  重定向错误输出**
标准错误输出实际上与标准输出类似，都是将数据输出到显示器上，只不过标准错误输出是输出错误信息，C语言中常用的错误输出就是perror了，如下面打开一个不存在的文件，就会直接在显示器上输出报错信息，因此重定向的方式与重定向标准输出一样。
```c
int main()
{
	open("123.txt",O_RDWR); 
	perror(NULL);
	return 0;
}
```

**4.  重定向恢复**
在进行重定向后，如果想要恢复到重定向之前的状态，可以在重定向之前用dup函数保留该文件描述符对应的文件表项，然后在需要恢复重定向的时候使用dup2重定向到原来的文件表项，以重定向后恢复标准输出为例：
```c
int main()
{
	int fd = -1;
	if((fd = open("test.txt",O_RDWR|O_CREAT|O_TRUNC)) == -1)
	{
		cout<<"open failed !"<<endl;
		return -1;
	}
	int oldfd = dup(1);     //保存标准输出对应的文件表项
/**
注意：并不是保存了文件表项本身，而是生成并保存了一个指向标准输出对应文件表项的文件描述符（oldfd）
**/
	dup2(fd,1);    //重定向标准输出到外部文件test.txt中
	cout<<"重定向标准输出测试！"<<endl;    //重定向测试
	dup2(oldfd,1);   //将重定向后的文件描述符1再次重定向到一开始保存的标准输出对应的文件表项中
	cout<<"重定向标准输出恢复测试！"<<endl;   //重定向恢复测试
	close(fd);
	close(oldfd);
	return 0;
	//在第一次重定向后，cout输出信息是输出到了外部文件中，当再次重定向进行恢复之后，此时的cout就将数据输出到显示器上了，回到了最原始的标准输出
}
```


## 管道（pipe）

管道是一个小的内核缓冲区，作为一对文件描述符公开给进程，一个用于读取，一个用于写入。将数据写入管道的一端，使该数据可用于从管道的另一端读取。**管道为进程提供了一种通信方式**。

下面的示例代码运行程序wc，标准输入连接到管道的读取端:
```c
int p[2]; //用来存储管道的两个文本描述符
char *argv[2]; //argv表示命令行输入
argv[0] = "wc";
argv[1] = 0;
pipe(p); //此时生成了管道，pipe是生成管道的系统调用
//在执行fork操作前已经生成了管道，那么fork操作后，父进程和子进程并行执行，每个进程中都有一个管道，且管道的文本描述符是相同的
if(fork() == 0) { //如果是子进程，执行如下分支的程序
	close(0);  //关闭标准输入，此时0成为了最小的文本描述符
	dup(p[0]); //上文讲到了dup的作用，生成了个新的指向p[0]对应文本表项的文本描述符，由于0是最小的文本描述符，所有dup会生成0作为文本描述符，标准输入对应了p[0]原本（管道用于读取的那一端）对应的文本表项。可以形象的理解为标准输入和管道的读取端对接上了（用水的事物和水管的出水口接上了）。
	close(p[0]); //p[0]和0指向的表项相同，不再需要
	close(p[1]); //读取端不需要写入，所以关闭
	exec("/bin/wc", argv); //子进程执行读取操作，读取被写入到管道的数据
} else {  //如果是父进程，执行如下分支的程序
	close(p[0]);  //写入端不需要读取管道的数据
	write(p[1], "hello world\n", 12) //p[1]是管道的进水口，程序向管道中写入数据（水龙头往管道中放水
	close(p[1]); //数据写完了，关闭管道（水龙头关闭了，水管也可以撤走了）
}

```
上述的例子中，如果管道的缓冲区中没有可用的数据，管道上的读操作要么等待数据被写入，要么等待指向写端的所有文件描述符被关闭，在后一种情况下，read将返回0。
**注意：由于父进程和子进程共有两对管道文本描述符，但整个数据传输过程中只会用到一对描述符，如果读取端不关闭多余的写入端口，那么wc将永远不会结束，即读取端永远等待自己没有使用的那个写入端写入数据**。
![[Pasted image 20230713171305.png]]


## 文件系统
暂时没看懂