
在上一章中，我介绍了go的基础语法（变量类型、判断语句、循环语句，服务器实现等），但是go的优势纠结是什么？

## 并发vs并行

```
并发：多线程程序在一个核的CPU上运行
并行：多线程程序在多个核的CPU上运行
```
在互联网公司，高并发是面试常见的问题。高并发意味着大流量，需要运用技术手段抵抗流量的冲击，这些手段好比操作流量，能让流量更平稳地被系统所处理，带给用户更好的体验。
当今无数的 Web 服务和互联网服务，本质上大部分都是 IO 密集型服务，什么是 IO 密集型服务？意思是处理的任务大多是和网络连接或读写相关的高耗时任务，高耗时是相对 CPU 计算逻辑处理型任务来说，两者的处理时间差距不是一个数量级的。
**IO 密集型服务的瓶颈不在 CPU 处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写。**

为了解决高并发问题，以前有两种解决方案
- 如果用多线程，高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换，非常消耗系统资源，同时多线程访问共享资源存在竞争问题
- 如果用多进程，不仅存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要额外引入进程间通信机制来解决。
- 
上述两种方案看起来都不太合适，高并发是go的主要特性之一，那么go可以轻易实现高并发处理？

## 协程

进程线程可以说是操作系统基础，运行在内核态。如果频繁的挂起和切换线程或进程，会消耗大量的系统资源，因此我们能否考虑在用户态实现一些类似线程的东西？当然可以，答案就是协程。这是go语言实现高并发的核心内容。

那究竟什么是协程呢？**协程 Coroutines 是一种比线程更加轻量级的微线程。**类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程。

**可以粗略的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。**
![[Pasted image 20230726175415.png]]

在发生调度切换时：
- 线程被内核调度，发生切换时，需要保存一个用户线程的状态到内存，恢复另一个线程状态到寄存器，然后更新调度器的数据结构，这几步操作涉及用户态到内核态转换，开销比较多。
- 协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方即可，再切换回来时，恢复先前保存的寄存器上下文和栈，这个过程直接操作用户空间栈，完全没有内核切换的开销。

在函数或方法调用前面加上关键字go，则同时运行一个新的协程
```go
package main
import (
	"fmt"
)

func f(i int) {
	fmt.Println("我是A")
}

func main() {
	fmt.Println("我是main")
	go f(1) //f函数单独开启一个协程运行则实现了并发运行，不同协程之间的高并发控制由go调度器实现

	go func(i int) {
		A(i)
	}(1)  //和上面一行等价

    fmt.Println("执行完了")
}


```

### 有栈协程和无栈协程

如下内容参考[这里](https://mthli.xyz/stackful-stackless/)，并进行了一定修改

协程运行在用户态，其实很多语言都可以实现，如今已经成为大多数语言的标配，例如 Golang 里的 goroutine，JavaScript 里的 async/await。尽管名称可能不同，但它们都可以被划分为两大类，一类是有栈（stackful）协程，例如 goroutine；一类是无栈（stackless）协程，例如 async/await

此处「有栈」和「无栈」的含义不是指协程在运行时是否需要栈，对于大多数语言来说，一个函数调用另一个函数，总是存在调用栈的；而是指协程是否可以在其**任意**嵌套函数（子函数、匿名函数等）中被挂起，此处的嵌套函数可以理解为子函数、匿名函数等。显然有栈协程是可以的，而无栈协程则不可以。似乎难以理解？不要慌，让我们先从函数调用栈开始讲起。

#### （1）函数调用栈

```
注意，文中所有讨论均基于 x86 平台，在 x86 平台中，调用栈的地址增长方向是从高位向低位增长的。并且本文选取 32 位系统作为讨论对象，因为 16 位已经过时了；而 64 位又稍显复杂，所占篇幅较大，但读者可以轻易地将本文内容推演至 64 位。
```

调用栈是一段连续的地址空间，无论是 caller（调用方）还是 callee（被调用方）都位于这段空间之内。而调用栈中一个函数所占用的地址空间我们称之为「栈帧」（stack frame），调用栈便是由若干个栈帧拼接而成的。一个典型的调用栈模型如下图所示:
![[Pasted image 20230813141334.png]]

图中涉及到几个关键点，Stack Pointer 即栈顶指针，总是指向调用栈的顶部地址，该地址由 esp 寄存器存储；Frame Pointer 即基址指针，总是指向当前栈帧（当前正在运行的子函数）的底部地址，该地址由 ebp 寄存器存储。Return Address 则在是 callee 返回后，caller 将继续执行的指令所在的地址；而指令地址是由 eip 寄存器负责读取的，且 eip 寄存器总是预先读取了**当前栈帧中**下一条将要执行的指令的地址。

我们可以很轻易地构造一段 C 代码，然后将其转换为汇编，看看底层究竟做了什么。笔者推荐使用 [Compiler Explorer](https://godbolt.org/) 查看汇编，相比直接在命令行使用 GCC/Clang 生成的汇编而言，更加简洁清晰。以下汇编由 x86_64 gcc 9.3 添加编译参数 `-m32` 生成，采用的是 AT&T 语法：

```c
int callee() { // callee:
               //   pushl %ebp
               //   movl  %esp, %ebp
               //   subl  $16, %esp
    int x = 0; //   movl  $0, -4(%ebp)
    return x;  //   movl -4(%ebp), %eax
               //   leave
               //   ret
}

int caller() { // caller:
               //   pushl %ebp
               //   movl  %esp, %ebp
    callee();  //   call  callee
    return 0;  //   movl  $0, %eax
               //   popl  %ebp
               //   ret
}
```
当 caller 调用 callee 时，执行了以下步骤（注意注释中的执行顺序）：
```c
callee:
    // 3. 将 caller 的栈帧底部地址入栈保存
    pushl %ebp
    // 4. 将此时的调用栈顶部地址作为 callee 的栈帧底部地址
    movl  %esp, %ebp
    // 5. 将调用栈顶部扩展 16 bytes 作为 callee 的栈帧空间；
    //    在 x86 平台中，调用栈的地址增长方向是从高位向低位增长的，
    //    所以这里用的是 subl 指令而不是 addl 指令
    subl  $16, %esp
    ...
caller:
    ...
    // "call callee" 等价于如下两条指令：
    // 1. 将 eip 存储的指令地址入栈保存；
    //    此时的指令地址即为 caller 的 return address，
    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址
    // 2. 然后跳转到 callee
    pushl %eip
    jmp callee
    ...
```

![[Pasted image 20230813152102.png]]
当 callee 返回 caller 时，则执行了以下步骤（注意注释中的执行顺序：

```c
callee:
    ...
    // "leave" 等价于如下两条指令：
    // 6. 将调用栈顶部与 callee 栈帧底部对齐，释放 callee 栈帧空间
    // 7. 将之前保存的 caller 的栈帧底部地址出栈并赋值给 ebp
    movl %ebp, %esp
    popl %ebp
    // "ret" 等价如下指令：
    // 8. 将之前保存的 caller 的 return address 出栈并赋值给 eip，
    //    即 caller 的 "movl $0, %eax" 这条指令所在的地址
    popl eip
caller:
    ...
    // 9. 从 callee 返回了，继续执行后续指令
    movl $0, %eax
    ...
```
![[Pasted image 20230813152139.png]]
其实整个过程栈空间发生的变化可以简单概况为：
1.  加入返回地址，加入caller的栈帧底部地址：区分调用栈中的caller栈帧和callee栈帧
2.  移动栈指针为callee开辟临时空间
3.  销毁为callee开辟的临时空间
4.  函数调用完成，运行下一条指令

#### （2） 有栈协程
实现一个协程的关键点在于如何保存、恢复和切换上下文。已知函数运行在调用栈上；如果将一个函数作为协程（使用go关键字+函数名的方式开启协程），我们很自然地联想到有栈协程是思想：
1、保存上下文即保存这个函数及其嵌套函数的栈帧对应的值，以及此时寄存器存储的值；
2、恢复上下文即是将这些保存的值重新写入对应的栈帧和寄存器；
3、而切换上下文无非就是保存当前正在运行的函数上下文，恢复下一个将要运行的函数的上下文。

这样我们就能理解为什么说有栈协程能在任意嵌套函数中被挂起，毕竟它都能保存和恢复自己完整的上下文了，那自然是在哪里被挂起都可以（午非就是栈空间复制多少进行保存的问题）。

#### （3） 无栈协程

相比于有栈协程直接切换栈帧的思路，无栈协程在不改变函数调用栈的情况下，采用类似生成器（generator）的思路实现了上下文切换，此处请直接阅读 [使用 C 语言实现协程](https://mthli.xyz/coroutines-in-c/) —— 尽管作者在文中没有说明，但这是一种无栈协程的实现。


## GMP模型

GMP模型是协程的调度模型，在理解它之前，我们需要先了解调度器是什么？是如何演变而来？是为了解决什么问题诞生？

#### 调度器的由来

**1、单进程时代**
我们知道，一切的软件都是跑在操作系统上，真正用来干活 (计算) 的是 CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是 “单进程时代” ，一切的程序只能串行发生。**在这个时代，不存在调度器。**
![[Pasted image 20230812135352.png]]
但是这样的系统会面临一个问题，当一个进程因为IO等操作陷入阻塞，会导致CPU运行的浪费。
为了解决这个问题，出现了最早的并发模型：多进程并发，当一个进程陷入阻塞，切换另一个等待执行的进程进入CPU运行，这样就能提高CPU的利用率。那么CPU应该按照什么规则安排进程的执行顺序呢？此时就有了调度器的概念。

**2、多进程/多线程时代**
在多进程 / 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。  
![[Pasted image 20230812135755.png]]

但新的问题就又出现了，进程这个单位很庞大，拥有太多的资源。进程的创建、切换、销毁，都会占用很长的CPU执行时间，如果进程过多，CPU 会浪费很多时间用于进程调度。即使后来出现了多线程模型，但是依然十分复杂。并且在如今互联网高并发的应用场景下，为每个任务创建线程是消耗大量内存，不现实。
总的来说，多进程/多线程模型存在的问题是：
1. 高内存占用
2. 调度过程有较高的时间成本，影响CPU利用率
![[Pasted image 20230812140034.png]]

提问：**怎么才能进一步提高 CPU 的利用率呢？**
答案：使用协程

**3、协程时代**

协程更多的是一种技术的概念，而非一种技术的实现，协程没有一个统一的定义，通俗地讲：协程就是一个基于用户态的轻量的线程，调度都由程序控制，它可以实现线程的一些功能，但又对内核不可见，因此调度的开销比线程小了很多，用线程的话可能我们最多只能开启几千个线程，但是协程我们可以做到几万甚至更多。

![[Pasted image 20230812161224.png]]
总的来说，协程是运行再用户态的轻量级的线程，使用协程有以下优点：
1. **节省内存**（线程占用内存大）
2. **节省线程创建时syscall的开销**（系统调用需要从用户态转换到内核态）
3. **协程的切换开销很小**
4. **可以配合非阻塞IO，提高系统性能**

其中对程序员最大的作用是：**对异步以及回调的封装，让程序员可以用写同步代码的方法写异步IO**
```go
func main() {   
	resp, _ := http.Get("https://xxxxxx")   
	body, _ := ioutil.ReadAll(resp.Body)   
	fmt.Println(string(body))
}
```

这段golang代码发起了一个网络IO请求，得到结果并输出，这是一个我们再熟悉不过的同步代码书写，但这其实是一个**异步/回调**的执行，在发起http请求后，go可以创建了一个新的**协程**去处理网络请求，并让出当前**线程**的资源去进行其他任务，当请求完成后再通过线程调度协程恢复，继续进行后续的处理。

按我自己的理解，简单来说：
线程是被动的，多线程处理并发问题时遇到阻塞，系统会进行线程上下文切换，执行其他线程。
协程是主动的：程序员知道这个任务是IO操作，然后提前在用户态阻塞，创建一个协程去完成这个任务。让协程背后真正在内核层面运行的线程去完成协程队列里的其他任务。从在内核里来看，根本就不知道上面发生了阻塞任务，因为一旦发生阻塞，就会把当前这个线程阻塞，连带着一系列对应的协程都被迫阻塞。
采用这样的方式，有效避免了：（1）线程上下文切换带来的开销（2）用户态和内核态切换的开销

因此，如何将大量的协程和少量的线程之间
![[Pasted image 20230813162803.png]]

#### 调度器的结构

GMP 模型是 Go 语言调度器采用的并发编程模型，它包含三个重要的组件：
1. Goroutine（G）
2. 逻辑处理器（P）
3. 操作系统线程（M）

实现是G的数据结构




## 信道（chan）

协程之间是如何进行信息交互的？答案是利用信道。在golang中，面对并发问题，我们应该优先考虑使用信道，如果通过信道解决不了，不得不使用共享内存来解决问题时，才需要考虑使用锁。

```go
package main  
  
func main() {  
    src := make(chan int, 3) //开启一个信道，缓冲区大小设定为3，如果容量为0则发送数据时必须立刻被接收，否则报错，此时的信道是无缓冲信道  
    go func() {  
       defer close(src)  
       for i := 0; i < 10; i++ {  
          src <- i // <-箭头表示数据流动，左侧为信道则是写入操作，右侧为信道则是读出  
       }  
    }()  
    for i := range src {  
       println(i) //使用range可以遍历信道 
    }  
}
```

注意：信道传递是深拷贝吗？
答案：数据结构可以分为两种：
- **值类型** ：String，Array，Int，Struct，Float，Bool
- **引用类型**：Slice，Map
这两种不同的类型在拷贝的时候，在拷贝的时候效果是完全不一样的，对于值类型来说，你的每一次拷贝，Go 都会新申请一块内存空间来存储它的值，改变其中一个变量，并不会影响另一个变量。因此，**信道传递是否是深拷贝取决于传入的数据是值类型还是引用类型**。

## 锁
Golang中锁有两种，互斥锁Mutex和读写锁RWMutex，后者的使用规则如下：
1. 读锁不能阻塞读锁
2. 读锁需要阻塞写锁，直到所有读锁都释放
3. 写锁需要阻塞读锁，直到所有写锁都释放
4. 写锁需要阻塞写锁

互斥锁和读写锁在使用上没有很大区别：
- 互斥锁使用`Lock()`进行加锁，使用`Unlock()`进行解锁
- 读写锁使用`RLock()`加读锁，使用`RUnlock()`进行解读锁；使用`Lock()`加写锁，使用`Unlock`解写锁，和互斥锁功能一致；

**但是二者的使用场景存在差异
- **互斥锁会将操作串行化，可以保证操作完全有序，适合资源只能由一个协程进行操作的情况，并发能力弱**
- **读写锁适合读多写少的情况，并发能力比较强**
```go
package main  
  
import (  
    "fmt"  
    "sync"    "time")  
  
func testMutex() {   //测试互斥锁
    count := 0  
    var l sync.Mutex  
    for i := 0; i < 10; i++ {  
       go func() {  
          l.Lock()  
          defer l.Unlock() 
          fmt.Println("---------互斥锁", count)   //按0-9的顺序打印
          count++  //只有当前协程完成修改之后，后续协程才能开锁读取数据，因此count按顺序打印
       }()  
    }  
}  

 func testRWMutex() {   //测试读写锁
    count := 0  
    var l sync.RWMutex  
    for i := 0; i < 10; i++ {  
       go func() {  
          l.RLock()  
          defer l.RUnlock()   
          fmt.Println("---------读写互斥锁", count)  //不会按0-9的顺序打印
          count++  
          //读锁，count的修改完成时，其他协程可能已经完成了count的输出，因此修改无效
       }()  
    }  
}  
  
func main() {  
    testMutex()  
    testRWMutex()  
    time.Sleep(5 * time.Second)  
}
```
